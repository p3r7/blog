{
    "version": "https://jsonfeed.org/version/1",
    "title": "Colorie",
    "home_page_url": "http://0.0.0.0:4000/",
    "feed_url": "http://0.0.0.0:4000/feed.json",
    "description": "Colorie - Single column blog and portfolio Jekyll theme",
    "icon": "http://0.0.0.0:4000/apple-touch-icon.png",
    "favicon": "http://0.0.0.0:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Colorie",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://0.0.0.0:4000/2019/12/06/psx-game-prototyping-using-org-babel",
            "title": "PSX game prototyping using org-babel",
            "summary": null,
            "content_text": "WhyThe setupChoosing a SDKPSNoobSDK",
            "content_html": "<h1 id=\"why\">Why</h1><h1 id=\"the-setup\">The setup</h1><h2 id=\"choosing-a-sdk\">Choosing a SDK</h2><p>PSNoobSDK</p>",
            "url": "http://0.0.0.0:4000/2019/12/06/psx-game-prototyping-using-org-babel",
            
            
            
            "tags": ["emacs","ansible","psx","retrocomputing"],
            
            "date_published": "2019-12-06T00:00:00+00:00",
            "date_modified": "2019-12-06T00:00:00+00:00",
            
                "author":  {
                "name": "Colorie",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://0.0.0.0:4000/2019/12/06/integratin-a-vt320-into-my-life",
            "title": "Integrating a VT320 into my life",
            "summary": "A tale of retrocopatibility",
            "content_text": "I like older eletronic devices.The originI guess it must come from my internship at Bull a few years ago.For the uninitiated, Bull was at a time a big supercomputer and workstation manufacturer, on par with IBM.Now they are more focusing on software.But during my time there, they had some pretty old beasts in a small air-conditionned room a few meters away from my desk.It was like a museum, composed of half a dozen workstation, all about the size of dishwasher, aligned in reverse chronological order.What seemed to be the oldest one had a monochrome display pluggued into it with comicall dimensions (it was about twice deeper than its diagonal width).They were all powered on, all the time.I asked my fellow coworkers why were those antiquated devices still up and running, they told me they didn’t know but were asked to not touch them, presuming they were used to help assist clients that were still using similar models.Aestetical considerations-&gt; TODO: talk about aestetic considerations-&gt; time when not every company was trying to copy apple designs-&gt; the latter not bad, but a bit bland and it’s nice to have some variety (toshiba satelite, vaio, thinkpads)The terminalWhile in my quest for cool retro devices, I came across the terminal.The hardware terminals.I vaguely knew that terminal apps were sort of an emulation of those old devices but I didn’t knew the whys and hows.And then I came accross pictures and blog posts of people using those deprecated appliances with modern *nix systems.I had to get one.Quickly, the VT220 looked like the most iconic model that wasn’t so large as to need a dedicated desk for it.But I realized 2 major problems:  they are pretty uncommon here is Europe  they need some electrical protection in case of power outageA good compromise was to look for a VT320, its slightly bigger and a tad less cute younger sibling.After several weeks or searching and refining an eBay alert query, I found a listing for one in decend shape at a pretty good price, with no keyboard.Hooking it up-&gt; no keyboard, no loging-&gt; unless hacking a bit-&gt; ansible playbook",
            "content_html": "<p>I like older eletronic devices.</p><h1 id=\"the-origin\">The origin</h1><p>I guess it must come from my internship at Bull a few years ago.</p><p>For the uninitiated, Bull was at a time a big supercomputer and workstation manufacturer, on par with IBM.</p><p>Now they are more focusing on software.</p><p>But during my time there, they had some pretty old beasts in a small air-conditionned room a few meters away from my desk.</p><p>It was like a museum, composed of half a dozen workstation, all about the size of dishwasher, aligned in reverse chronological order.</p><p>What seemed to be the oldest one had a monochrome display pluggued into it with comicall dimensions (it was about twice deeper than its diagonal width).</p><p><strong>They were all powered on, all the time.</strong></p><p>I asked my fellow coworkers why were those antiquated devices still up and running, they told me they didn’t know but were asked to not touch them, presuming they were used to help assist clients that were still using similar models.</p><h1 id=\"aestetical-considerations\">Aestetical considerations</h1><p>-&gt; TODO: talk about aestetic considerations</p><p>-&gt; time when not every company was trying to copy apple designs</p><p>-&gt; the latter not bad, but a bit bland and it’s nice to have some variety (toshiba satelite, vaio, thinkpads)</p><h1 id=\"the-terminal\">The terminal</h1><p>While in my quest for cool retro devices, I came across the terminal.</p><p>The <strong>hardware</strong> terminals.</p><p>I vaguely knew that terminal apps were sort of an emulation of those old devices but I didn’t knew the whys and hows.</p><p>And then I came accross pictures and blog posts of people using those deprecated appliances with modern *nix systems.</p><p>I had to get one.</p><p>Quickly, the VT220 looked like the most iconic model that wasn’t so large as to need a dedicated desk for it.</p><p>But I realized 2 major problems:</p><ul>  <li>they are pretty uncommon here is Europe</li>  <li>they need some electrical protection in case of power outage</li></ul><p>A good compromise was to look for a VT320, its slightly bigger and a tad less cute younger sibling.</p><p>After several weeks or searching and refining an eBay alert query, I found a listing for one in decend shape at a pretty good price, with <strong>no keyboard</strong>.</p><h1 id=\"hooking-it-up\">Hooking it up</h1><p>-&gt; no keyboard, no loging</p><p>-&gt; unless hacking a bit</p><p>-&gt; ansible playbook</p>",
            "url": "http://0.0.0.0:4000/2019/12/06/integratin-a-vt320-into-my-life",
            
            
            
            "tags": ["ansible","retrocomputing"],
            
            "date_published": "2019-12-06T00:00:00+00:00",
            "date_modified": "2019-12-06T00:00:00+00:00",
            
                "author":  {
                "name": "Colorie",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://0.0.0.0:4000/2019/12/06/emacs-theme-overrides",
            "title": "Emacs theme overrides",
            "summary": "Extracting a nice feature from spacemacs",
            "content_text": "IntroductionI don’t use any starter kit.I’ve built my emacs config by first blindly integrating packages and copy-pasting snippets from all around the web.Progressively I realized that I didn’t like some behaviours and that’s when I started to dwelves into elisp and emacs intricacies.A standard way to modify a behaviour is to use advices or function redefinition. But in my ignorance I often just forked packages and monkey-patched them until I found the appropriate behaviour.This way to proceed included themes.Quite often I would like a theme, but would not like a specific face in it. Or it would lack support for other packages I’d be using.So forking I did.A better solutionThis sucks, as themes, like any other packages, regularly get updates.And tracking those changes and integrating them back is a real hassle.So I searched for a way to only override specific faces. And found that someone had already implemented a solution.And that solution was bundled into spacemacs.The problem-&gt; spacemacs-only solution-&gt; extracting it as a proper package-&gt; usage",
            "content_html": "<h1 id=\"introduction\">Introduction</h1><p>I don’t use any starter kit.</p><p>I’ve built my emacs config by first blindly integrating packages and copy-pasting snippets from all around the web.</p><p>Progressively I realized that I didn’t like some behaviours and that’s when I started to dwelves into elisp and emacs intricacies.</p><p>A standard way to modify a behaviour is to use advices or function redefinition. But in my ignorance I often just forked packages and monkey-patched them until I found the appropriate behaviour.</p><p>This way to proceed included themes.</p><p>Quite often I would like a theme, but would not like a specific face in it. Or it would lack support for other packages I’d be using.</p><p>So forking I did.</p><h1 id=\"a-better-solution\">A better solution</h1><p>This sucks, as themes, like any other packages, regularly get updates.</p><p>And tracking those changes and integrating them back is a real hassle.</p><p>So I searched for a way to only override specific faces. And found that someone had already implemented a solution.</p><p>And that solution was bundled into spacemacs.</p><h1 id=\"the-problem\">The problem</h1><p>-&gt; spacemacs-only solution</p><p>-&gt; extracting it as a proper package</p><p>-&gt; usage</p>",
            "url": "http://0.0.0.0:4000/2019/12/06/emacs-theme-overrides",
            
            
            
            
            
            "date_published": "2019-12-06T00:00:00+00:00",
            "date_modified": "2019-12-06T00:00:00+00:00",
            
                "author":  {
                "name": "Colorie",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://0.0.0.0:4000/2019/12/05/yasnipper",
            "title": "YASnipper",
            "summary": "Using YASnippet like an old Emacs hacker",
            "content_text": "tl;dr: the provided code allows you to let YASnippet expand snippets preentively with the SPC key, and you to tame it with a second SPC keystroke.IntroductionI had been an Emacs user for almost 10 years whithout relying on YASnippet or any snippet extension system.I had heard of it, but never took the time to really investigate, fearing that it would conflict with whatever completion-at-point package I’d be using.By reading the doc, I realized that conflicts could easily be tamed and that I could bind yas-expand to C-j to mimick emmet-mode’s recommended key. Indeed, this key is generally bound to newline-and-indent which is useless as I have aggressive-indent auto-indenting stuff for me.An old taleFurther down the documentation, I came accross this section about the condition system.It starts with the story of a dreaded old Emacs hacker that got used to having its expansions bounf to SPC…Wait… WHAT!? That SPC? the one I use to separate words, symbols and things alike?Yup, that one, it went on. And thanks to the integrated condition system one could have YAS be smart enough to tell whether it needed to expand or not.Like if it could anticipate the need for an expansion before you realized it…The experimentFor fun, I’ve tried using YAS like this and realized that there would be occasions for which you would like to have a symbol named with a short name…And that name would correspong to a snippet…And it would expand…And make you want to rage-disable the minor mode.A solutionTo keep our sanity, we would have to roll up our sleeves and hack it till we make it.We could indeed follow the doc and attempt to build a set of rules around the condition system. For this we’d have to try to predict every use-case, for every language. That would practically corespond to building a small neural net and I just… no.We could instead let YAS do its unwanted expansion but have a quick and effortless way to tell it to stop. Like by pressing that precious SPC key again.For that we need a way to test when YAS just expanded.(defvar prf/yas-last-expand-success-timestamp nil \"Timestamp of last sucessful yas-expand\")(defvar prf/yas-cancel-on-repeat-delay 1 \"Max time to wait for allowing to cancel snippet expansion\")(defun prf/yas-update-last-expand-success-timestamp ()  (setq prf/yas-last-expand-success-timestamp (float-time)))(add-hook 'yas-before-expand-snippet-hook #'prf/yas-update-last-expand-success-timestamp)(defun prf/yas/just-expanded-p ()  \"Returns t when there is a current active expansion or when expanded during the last `prf/yas-cancel-on-repeat-delay' seconds.\"  (or (yas-active-snippets)      (&gt;= prf/yas-cancel-on-repeat-delay          (- (float-time) prf/yas-last-expand-success-timestamp))))Ok cool, now we want to conditionally insert a space character OR yas-expand OR cancel last expansion.That’s a lot to ask. Thanksfully YAS already does half the job for us with it’s function variable yas-maybe-expand. What it does is basically create a conditional key (as a menu entry).Let’s look at its definition (with truncated docstrings):(defconst yas-maybe-expand  '(menu-item \"\" yas-expand :filter yas-maybe-expand-abbrev-key-filter))(defun yas-maybe-expand-abbrev-key-filter (cmd)  \"Return CMD if there is an expandable snippet at point.\"  (when (let ((yas--condition-cache-timestamp (current-time)))          (yas--templates-for-key-at-point))    cmd))We could reuse the same sytem to satisfy our purpose. This gives:(defconst prf/yas-maybe-expand-or-cancel  '(menu-item \"\" prf/yas-expand-or-cancel :filter prf/yas-maybe-expand-or-cancel-key-filter))(defun prf/yas-expand-or-cancel ()  (interactive)  (cond   ((yas-active-snippets)    (yas-abort-snippet (car (yas-active-snippets)))    (undo 1)    (just-one-space))   ((&gt;= prf/yas-cancel-on-repeat-delay        (- (float-time) prf/yas-last-expand-success-timestamp))    (undo 1)    (just-one-space))   (t    (yas-expand))))(defun prf/yas-maybe-expand-or-cancel-key-filter (cmd)  \"Return CMD if there is an expandable snippet at point or we just expanded one.\"  (if (prf/yas/just-expanded-p)      cmd    (yas-maybe-expand-abbrev-key-filter cmd)))And to bind it:(define-key yas-minor-mode-map (kbd \"SPC\") prf/yas-maybe-expand-or-cancel)And voilà! Now we can finally grasp the feeling of being an old Emacs hacker.",
            "content_html": "<p><strong>tl;dr: the provided code allows you to let YASnippet expand snippets preentively with the SPC key, and you to tame it with a second SPC keystroke.</strong></p><h1 id=\"introduction\">Introduction</h1><p>I had been an Emacs user for almost 10 years whithout relying on YASnippet or any snippet extension system.</p><p>I had heard of it, but never took the time to really investigate, fearing that it would conflict with whatever completion-at-point package I’d be using.</p><p>By reading the doc, I realized that conflicts could <a href=\"http://joaotavora.github.io/yasnippet/faq.html#org3e0ab30\">easily be tamed</a> and that I could bind <code class=\"highlighter-rouge\">yas-expand</code> to <code class=\"highlighter-rouge\">C-j</code> to mimick <a href=\"https://github.com/smihica/emmet-mode\">emmet-mode</a>’s recommended key. Indeed, this key is generally bound to <code class=\"highlighter-rouge\">newline-and-indent</code> which is useless as I have <a href=\"https://github.com/Malabarba/aggressive-indent-mode\">aggressive-indent</a> auto-indenting stuff for me.</p><h1 id=\"an-old-tale\">An old tale</h1><p>Further down the documentation, I came accross <a href=\"http://joaotavora.github.io/yasnippet/snippet-expansion.html#org075c5ff\">this section about the condition system</a>.</p><p>It starts with the story of a dreaded <em>old Emacs hacker</em> that got used to having its expansions bounf to <code class=\"highlighter-rouge\">SPC</code>…</p><p>Wait… WHAT!? <strong>That</strong> <code class=\"highlighter-rouge\">SPC</code>? the one I use to separate words, symbols and things alike?</p><p>Yup, that one, it went on. And thanks to the integrated <strong>condition</strong> system one could have YAS be smart enough to tell whether it needed to expand or not.</p><p>Like if it could anticipate the need for an expansion before you realized it…</p><h1 id=\"the-experiment\">The experiment</h1><p>For fun, I’ve tried using YAS like this and realized that there would be occasions for which you would like to have a symbol named with a short name…</p><p>And that name would correspong to a snippet…</p><p>And it would expand…</p><p>And make you want to rage-disable the minor mode.</p><h1 id=\"a-solution\">A solution</h1><p>To keep our sanity, we would have to roll up our sleeves and hack it till we make it.</p><p>We could indeed follow the doc and attempt to build a set of rules around the condition system. For this we’d have to try to predict every use-case, for every language. That would practically corespond to building a small neural net and I just… no.</p><p>We could instead let YAS do its unwanted expansion but have a quick and effortless way to tell it to stop. <strong>Like by pressing that precious <code class=\"highlighter-rouge\">SPC</code> key again.</strong></p><p>For that we need a way to test when YAS just expanded.</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nb\">defvar</span> <span class=\"nv\">prf/yas-last-expand-success-timestamp</span> <span class=\"no\">nil</span> <span class=\"s\">\"Timestamp of last sucessful yas-expand\"</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">defvar</span> <span class=\"nv\">prf/yas-cancel-on-repeat-delay</span> <span class=\"mi\">1</span> <span class=\"s\">\"Max time to wait for allowing to cancel snippet expansion\"</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">prf/yas-update-last-expand-success-timestamp</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"k\">setq</span> <span class=\"nv\">prf/yas-last-expand-success-timestamp</span> <span class=\"p\">(</span><span class=\"nv\">float-time</span><span class=\"p\">)))</span><span class=\"p\">(</span><span class=\"nv\">add-hook</span> <span class=\"ss\">'yas-before-expand-snippet-hook</span> <span class=\"nf\">#'</span><span class=\"nv\">prf/yas-update-last-expand-success-timestamp</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">prf/yas/just-expanded-p</span> <span class=\"p\">()</span>  <span class=\"s\">\"Returns t when there is a current active expansion or when expanded during the last `prf/yas-cancel-on-repeat-delay' seconds.\"</span>  <span class=\"p\">(</span><span class=\"nb\">or</span> <span class=\"p\">(</span><span class=\"nv\">yas-active-snippets</span><span class=\"p\">)</span>      <span class=\"p\">(</span><span class=\"nb\">&gt;=</span> <span class=\"nv\">prf/yas-cancel-on-repeat-delay</span>          <span class=\"p\">(</span><span class=\"nb\">-</span> <span class=\"p\">(</span><span class=\"nv\">float-time</span><span class=\"p\">)</span> <span class=\"nv\">prf/yas-last-expand-success-timestamp</span><span class=\"p\">))))</span></code></pre></div></div><p>Ok cool, now we want to conditionally insert a space character OR yas-expand OR cancel last expansion.</p><p>That’s a lot to ask. Thanksfully YAS already does half the job for us with it’s <del>function</del> variable <code class=\"highlighter-rouge\">yas-maybe-expand</code>. What it does is basically create a conditional key (as a menu entry).</p><p>Let’s look at its definition (with truncated docstrings):</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nv\">defconst</span> <span class=\"nv\">yas-maybe-expand</span>  <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"nv\">menu-item</span> <span class=\"s\">\"\"</span> <span class=\"nv\">yas-expand</span> <span class=\"ss\">:filter</span> <span class=\"nv\">yas-maybe-expand-abbrev-key-filter</span><span class=\"p\">))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">yas-maybe-expand-abbrev-key-filter</span> <span class=\"p\">(</span><span class=\"nv\">cmd</span><span class=\"p\">)</span>  <span class=\"s\">\"Return CMD if there is an expandable snippet at point.\"</span>  <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">yas--condition-cache-timestamp</span> <span class=\"p\">(</span><span class=\"nv\">current-time</span><span class=\"p\">)))</span>          <span class=\"p\">(</span><span class=\"nv\">yas--templates-for-key-at-point</span><span class=\"p\">))</span>    <span class=\"nv\">cmd</span><span class=\"p\">))</span></code></pre></div></div><p>We could reuse the same sytem to satisfy our purpose. This gives:</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nv\">defconst</span> <span class=\"nv\">prf/yas-maybe-expand-or-cancel</span>  <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"nv\">menu-item</span> <span class=\"s\">\"\"</span> <span class=\"nv\">prf/yas-expand-or-cancel</span> <span class=\"ss\">:filter</span> <span class=\"nv\">prf/yas-maybe-expand-or-cancel-key-filter</span><span class=\"p\">))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">prf/yas-expand-or-cancel</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"nv\">interactive</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"nb\">cond</span>   <span class=\"p\">((</span><span class=\"nv\">yas-active-snippets</span><span class=\"p\">)</span>    <span class=\"p\">(</span><span class=\"nv\">yas-abort-snippet</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"p\">(</span><span class=\"nv\">yas-active-snippets</span><span class=\"p\">)))</span>    <span class=\"p\">(</span><span class=\"nv\">undo</span> <span class=\"mi\">1</span><span class=\"p\">)</span>    <span class=\"p\">(</span><span class=\"nv\">just-one-space</span><span class=\"p\">))</span>   <span class=\"p\">((</span><span class=\"nb\">&gt;=</span> <span class=\"nv\">prf/yas-cancel-on-repeat-delay</span>        <span class=\"p\">(</span><span class=\"nb\">-</span> <span class=\"p\">(</span><span class=\"nv\">float-time</span><span class=\"p\">)</span> <span class=\"nv\">prf/yas-last-expand-success-timestamp</span><span class=\"p\">))</span>    <span class=\"p\">(</span><span class=\"nv\">undo</span> <span class=\"mi\">1</span><span class=\"p\">)</span>    <span class=\"p\">(</span><span class=\"nv\">just-one-space</span><span class=\"p\">))</span>   <span class=\"p\">(</span><span class=\"no\">t</span>    <span class=\"p\">(</span><span class=\"nv\">yas-expand</span><span class=\"p\">))))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">prf/yas-maybe-expand-or-cancel-key-filter</span> <span class=\"p\">(</span><span class=\"nv\">cmd</span><span class=\"p\">)</span>  <span class=\"s\">\"Return CMD if there is an expandable snippet at point or we just expanded one.\"</span>  <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">prf/yas/just-expanded-p</span><span class=\"p\">)</span>      <span class=\"nv\">cmd</span>    <span class=\"p\">(</span><span class=\"nv\">yas-maybe-expand-abbrev-key-filter</span> <span class=\"nv\">cmd</span><span class=\"p\">)))</span></code></pre></div></div><p>And to bind it:</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nv\">define-key</span> <span class=\"nv\">yas-minor-mode-map</span> <span class=\"p\">(</span><span class=\"nv\">kbd</span> <span class=\"s\">\"SPC\"</span><span class=\"p\">)</span> <span class=\"nv\">prf/yas-maybe-expand-or-cancel</span><span class=\"p\">)</span></code></pre></div></div><p>And <em>voilà</em>! Now we can finally grasp the feeling of being an old Emacs hacker.</p>",
            "url": "http://0.0.0.0:4000/2019/12/05/yasnipper",
            
            
            
            
            
            "date_published": "2019-12-05T00:00:00+00:00",
            "date_modified": "2019-12-05T00:00:00+00:00",
            
                "author":  {
                "name": "Colorie",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://0.0.0.0:4000/2019/12/05/tramp-autologin-insanity",
            "title": "Better TRAMP autologin",
            "summary": "Using SSH keys with tramps",
            "content_text": "IntroductionFor those not in the know, TRAMP is one of Emacs’ killer apps. It’s a package that allows to interact with remote systems through a variety of protocols.Such interactions include opening shells and browsing remote file trees as if they were locally mounted. You can even bounce across several machines like if it was nothing (it’s called multi-hops).But there is one thing can break these otherwise seemless interactions: login prompts.The Authinfo wayTo get rid of them, emacs offers natively support for Gnus Authinfo and .netrc files via its auth-source package:(require 'dash)(use-package auth-source  :demand  :no-require t  :config  (setq auth-sources (-filter #'file-exists-p '(\"~/.authinfo.gpg\" \"~/.authinfo\" \"~/.netrc\"))))Now you can just create a ~/.authinfo like this:machine raspi login pi password raspberryAnd then C-x f /ssh:pi@raspi:/ and it will connect automatically, yey!…Except that sucks.SSH keys to the rescueIndeed passwords suck. Big time. Even more so when you have a gazillion of remote hosts to connect to.SSH keys (aka identity files, aka certificates) are a way smarter (and in most cases safer) way to proceed.Given you have a master key for connecting to all of your machines, just have to drop into your ~/.ssh/config:Host *    User eigen    IdentityFile ~/.ssh/eigen-identityAnd you could connect to any server for which this key is known for user eigen.The PuTTY dilemnaIf you’re on Windows, you’re most likely using PuTTY/plink as an SSH alternative.TRAMP, in all its glory, supports PuTTY (use the /pscp: method, that’s the one you’re looking for).PuTTY has an equivalent way to set a default key, via a Default Setting or through Pageant.The former only works if you’re saving each and every of your hosts as a connection profile and access it with /plinkx:&lt;PROFILE&gt;:.The latter only seems to load when lauching putty.exe (GUI interface).So here comes time for adventure insanity.Insanity (or elisp-bind all the things)Another cross-platform solution is to do this in pure elisp.The trick is to enrich tramp-methods with an additionnal args corresponding to the identity file option (-i).Thus we need some utils to alter those method definitions.(beware, this code is not the cleanest)  Click to reveal!  ;; ------------------------------------------------------------------------;; DEPS(require 'tramp)(require 'dash)(require 'subr-x);; ------------------------------------------------------------------------;; VARS(defvar tramp-plinki-ppk nil \"Default PuTTY identity file path\")(defvar tramp-plinki-methods '(\"pscp\" \"plink\" \"plinkx\" \"psftp\"));; ------------------------------------------------------------------------;; TRAMP METHODS ARGS(defun tramp-plinki--add-certificate-login-arg (tramp-login-args)  (let ((login-args (car (cdr tramp-login-args))))    (if (string= \"\" tramp-plinki-ppk)        tramp-login-args      (add-to-list 'login-args `(\"-i\" ,(concat \"\\\"\" tramp-plinki-ppk \"\\\"\")))      `(tramp-login-args ,login-args))))(defun tramp-plinki--add-certificate-copy-arg (tramp-copy-args)  (let ((copy-args (car (cdr tramp-copy-args))))    (if (string= \"\" tramp-plinki-ppk)        tramp-copy-args      (add-to-list 'copy-args `(\"-i\" ,(concat \"\\\"\" tramp-plinki-ppk \"\\\"\")))      `(tramp-copy-args ,copy-args))));; ------------------------------------------------------------------------;; TRAMP METHODS;; REVIEW: seems to eval whole method-def-args, which is unwanted(defun tramp-plinki--add-certificate-login-arg-to-method (tramp-method-def)  (let ((method-name (car tramp-method-def))        (method-def-args (cdr tramp-method-def)))    (cons method-name          (-map-when           (lambda (e) (equal (car e) 'tramp-login-args))           #'tramp-plinki--add-certificate-login-arg           method-def-args))))(defun tramp-plinki--add-certificate-copy-arg-to-method (tramp-method-def)  (let ((method-name (car tramp-method-def))        (method-def-args (cdr tramp-method-def)))    (cons method-name          (-map-when           (lambda (e) (equal (car e) 'tramp-copy-args))           #'tramp-plinki--add-certificate-copy-arg           method-def-args))))(defun tramp-plinki--get-enriched-tramp-methods ()  (-map-when   (lambda (e) (member (car e) tramp-plinki-methods))   (lambda (e) (thread-first e            (tramp-plinki--add-certificate-login-arg-to-method)            (tramp-plinki--add-certificate-copy-arg-to-method)))   tramp-methods))  Then we could either override existing methods:(defun tramp-plinki-enrich-existing ()  (setq tramp-methods (tramp-plinki--get-enriched-tramp-methods)));; then run (tramp-plinki-enrich-existing)Or register new ones with an i suffix:(defun tramp-plinki--suffix-method-name (tramp-method-def)  (let ((method-name (car tramp-method-def))        (method-def-args (cdr tramp-method-def)))    (cons (concat method-name \"i\")          method-def-args)))(defun tramp-plinki--get-enriched-with-new-tramp-methods ()  (-map-when   (lambda (e) (member (car e) tramp-plinki-methods))   (lambda (e) (thread-first e            ;; (tramp-plinki--register-tramp-completion-fun)            (tramp-plinki--suffix-method-name)            (tramp-plinki--add-certificate-login-arg-to-method)            (tramp-plinki--add-certificate-copy-arg-to-method)))   tramp-methods))(defun tramp-plinki-register-new ()  (when (not tramp-plinki-ppk)    (error \"empty value for tramp-plinki-ppk\"))  (setq tramp-methods (tramp-plinki--get-enriched-with-new-tramp-methods))  (-map-when   (lambda (e) (member (car e) tramp-plinki-methods))   (lambda (e)     (let ((method-name (car tramp-method-def))           (tramp-set-completion-function (concat method-name \"i\") tramp-completion-function-alist-ssh)))     nil)   tramp-methods));; then run (tramp-plinki-register-new)The beauty of this is that if your key is not known to the remote host, it would still prompt you for a password without failing.",
            "content_html": "<h1 id=\"introduction\">Introduction</h1><p>For those not in the know, <a href=\"https://www.gnu.org/software/tramp/\">TRAMP</a> is one of Emacs’ killer apps. It’s a package that allows to interact with remote systems through a <a href=\"https://www.gnu.org/software/tramp/#Inline-methods\">variety</a> <a href=\"https://www.gnu.org/software/tramp/#External-methods\">of</a> <a href=\"https://www.gnu.org/software/tramp/#GVFS-based-methods\">protocols</a>.</p><p>Such interactions include opening shells and browsing remote file trees as if they were locally mounted. You can even bounce across several machines like if it was nothing (it’s called <a href=\"https://www.gnu.org/software/emacs/manual/html_node/tramp/Ad_002dhoc-multi_002dhops.html\">multi-hops</a>).</p><p>But there is one thing can break these otherwise seemless interactions: login prompts.</p><h1 id=\"the-authinfo-way\">The Authinfo way</h1><p>To get rid of them, emacs offers natively support for Gnus Authinfo and .netrc files via its <code class=\"highlighter-rouge\">auth-source</code> package:</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">'dash</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">use-package</span> <span class=\"nv\">auth-source</span>  <span class=\"ss\">:demand</span>  <span class=\"ss\">:no-require</span> <span class=\"no\">t</span>  <span class=\"ss\">:config</span>  <span class=\"p\">(</span><span class=\"k\">setq</span> <span class=\"nv\">auth-sources</span> <span class=\"p\">(</span><span class=\"nv\">-filter</span> <span class=\"nf\">#'</span><span class=\"nv\">file-exists-p</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"s\">\"~/.authinfo.gpg\"</span> <span class=\"s\">\"~/.authinfo\"</span> <span class=\"s\">\"~/.netrc\"</span><span class=\"p\">))))</span></code></pre></div></div><p>Now you can just create a <code class=\"highlighter-rouge\">~/.authinfo</code> like this:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>machine raspi login pi password raspberry</code></pre></div></div><p>And then <code class=\"highlighter-rouge\">C-x f /ssh:pi@raspi:/</code> and it will connect automatically, yey!</p><p>…Except that sucks.</p><h1 id=\"ssh-keys-to-the-rescue\">SSH keys to the rescue</h1><p>Indeed passwords suck. Big time. Even more so when you have a gazillion of remote hosts to connect to.</p><p>SSH keys (aka identity files, aka certificates) are a way smarter (and in most cases safer) way to proceed.</p><p>Given you have a master key for connecting to all of your machines, just have to drop into your <code class=\"highlighter-rouge\">~/.ssh/config</code>:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Host *    User eigen    IdentityFile ~/.ssh/eigen-identity</code></pre></div></div><p>And you could connect to any server for which this key is known for user <code class=\"highlighter-rouge\">eigen</code>.</p><h1 id=\"the-putty-dilemna\">The PuTTY dilemna</h1><p>If you’re on Windows, you’re most likely using PuTTY/plink as an SSH alternative.</p><p>TRAMP, in all its glory, supports PuTTY (use the <code class=\"highlighter-rouge\">/pscp:</code> method, that’s the one you’re looking for).</p><p>PuTTY has an equivalent way to set a default key, via a <a href=\"https://the.earth.li/~sgtatham/putty/0.73/htmldoc/Chapter4.html#config-saving\">Default Setting</a> or through <a href=\"https://the.earth.li/~sgtatham/putty/0.73/htmldoc/Chapter9.html\">Pageant</a>.</p><p>The former only works if you’re saving each and every of your hosts as a connection profile and access it with <code class=\"highlighter-rouge\">/plinkx:&lt;PROFILE&gt;:</code>.</p><p>The latter only seems to load when lauching putty.exe (GUI interface).</p><p>So here comes time for <del>adventure</del> insanity.</p><h1 id=\"insanity-or-elisp-bind-all-the-things\">Insanity (or elisp-bind all the things)</h1><p>Another cross-platform solution is to do this in pure elisp.</p><p>The trick is to enrich <code class=\"highlighter-rouge\">tramp-methods</code> with an additionnal args corresponding to the identity file option (<code class=\"highlighter-rouge\">-i</code>).</p><p>Thus we need some utils to alter those method definitions.</p><p>(beware, this code is not the cleanest)</p><details>  <summary>Click to reveal!</summary>  <div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">;; ------------------------------------------------------------------------</span><span class=\"c1\">;; DEPS</span><span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">'tramp</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">'dash</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">require</span> <span class=\"ss\">'subr-x</span><span class=\"p\">)</span><span class=\"c1\">;; ------------------------------------------------------------------------</span><span class=\"c1\">;; VARS</span><span class=\"p\">(</span><span class=\"nb\">defvar</span> <span class=\"nv\">tramp-plinki-ppk</span> <span class=\"no\">nil</span> <span class=\"s\">\"Default PuTTY identity file path\"</span><span class=\"p\">)</span><span class=\"p\">(</span><span class=\"nb\">defvar</span> <span class=\"nv\">tramp-plinki-methods</span> <span class=\"o\">'</span><span class=\"p\">(</span><span class=\"s\">\"pscp\"</span> <span class=\"s\">\"plink\"</span> <span class=\"s\">\"plinkx\"</span> <span class=\"s\">\"psftp\"</span><span class=\"p\">))</span><span class=\"c1\">;; ------------------------------------------------------------------------</span><span class=\"c1\">;; TRAMP METHODS ARGS</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--add-certificate-login-arg</span> <span class=\"p\">(</span><span class=\"nv\">tramp-login-args</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">login-args</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nv\">tramp-login-args</span><span class=\"p\">))))</span>    <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">string=</span> <span class=\"s\">\"\"</span> <span class=\"nv\">tramp-plinki-ppk</span><span class=\"p\">)</span>        <span class=\"nv\">tramp-login-args</span>      <span class=\"p\">(</span><span class=\"nv\">add-to-list</span> <span class=\"ss\">'login-args</span> <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"s\">\"-i\"</span> <span class=\"o\">,</span><span class=\"p\">(</span><span class=\"nv\">concat</span> <span class=\"s\">\"\\\"\"</span> <span class=\"nv\">tramp-plinki-ppk</span> <span class=\"s\">\"\\\"\"</span><span class=\"p\">)))</span>      <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">tramp-login-args</span> <span class=\"o\">,</span><span class=\"nv\">login-args</span><span class=\"p\">))))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--add-certificate-copy-arg</span> <span class=\"p\">(</span><span class=\"nv\">tramp-copy-args</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">copy-args</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nv\">tramp-copy-args</span><span class=\"p\">))))</span>    <span class=\"p\">(</span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">string=</span> <span class=\"s\">\"\"</span> <span class=\"nv\">tramp-plinki-ppk</span><span class=\"p\">)</span>        <span class=\"nv\">tramp-copy-args</span>      <span class=\"p\">(</span><span class=\"nv\">add-to-list</span> <span class=\"ss\">'copy-args</span> <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"s\">\"-i\"</span> <span class=\"o\">,</span><span class=\"p\">(</span><span class=\"nv\">concat</span> <span class=\"s\">\"\\\"\"</span> <span class=\"nv\">tramp-plinki-ppk</span> <span class=\"s\">\"\\\"\"</span><span class=\"p\">)))</span>      <span class=\"o\">`</span><span class=\"p\">(</span><span class=\"nv\">tramp-copy-args</span> <span class=\"o\">,</span><span class=\"nv\">copy-args</span><span class=\"p\">))))</span><span class=\"c1\">;; ------------------------------------------------------------------------</span><span class=\"c1\">;; TRAMP METHODS</span><span class=\"c1\">;; REVIEW: seems to eval whole method-def-args, which is unwanted</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--add-certificate-login-arg-to-method</span> <span class=\"p\">(</span><span class=\"nv\">tramp-method-def</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">method-name</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">))</span>        <span class=\"p\">(</span><span class=\"nv\">method-def-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">)))</span>    <span class=\"p\">(</span><span class=\"nb\">cons</span> <span class=\"nv\">method-name</span>          <span class=\"p\">(</span><span class=\"nv\">-map-when</span>           <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">equal</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"ss\">'tramp-login-args</span><span class=\"p\">))</span>           <span class=\"nf\">#'</span><span class=\"nv\">tramp-plinki--add-certificate-login-arg</span>           <span class=\"nv\">method-def-args</span><span class=\"p\">))))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--add-certificate-copy-arg-to-method</span> <span class=\"p\">(</span><span class=\"nv\">tramp-method-def</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">method-name</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">))</span>        <span class=\"p\">(</span><span class=\"nv\">method-def-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">)))</span>    <span class=\"p\">(</span><span class=\"nb\">cons</span> <span class=\"nv\">method-name</span>          <span class=\"p\">(</span><span class=\"nv\">-map-when</span>           <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">equal</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"ss\">'tramp-copy-args</span><span class=\"p\">))</span>           <span class=\"nf\">#'</span><span class=\"nv\">tramp-plinki--add-certificate-copy-arg</span>           <span class=\"nv\">method-def-args</span><span class=\"p\">))))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--get-enriched-tramp-methods</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"nv\">-map-when</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">member</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"nv\">tramp-plinki-methods</span><span class=\"p\">))</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">thread-first</span> <span class=\"nv\">e</span>            <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--add-certificate-login-arg-to-method</span><span class=\"p\">)</span>            <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--add-certificate-copy-arg-to-method</span><span class=\"p\">)))</span>   <span class=\"nv\">tramp-methods</span><span class=\"p\">))</span></code></pre></div>  </div></details><p>Then we could either override existing methods:</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki-enrich-existing</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"k\">setq</span> <span class=\"nv\">tramp-methods</span> <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--get-enriched-tramp-methods</span><span class=\"p\">)))</span><span class=\"c1\">;; then run (tramp-plinki-enrich-existing)</span></code></pre></div></div><p>Or register new ones with an <strong>i</strong> suffix:</p><div class=\"language-emacs-lisp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--suffix-method-name</span> <span class=\"p\">(</span><span class=\"nv\">tramp-method-def</span><span class=\"p\">)</span>  <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">method-name</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">))</span>        <span class=\"p\">(</span><span class=\"nv\">method-def-args</span> <span class=\"p\">(</span><span class=\"nb\">cdr</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">)))</span>    <span class=\"p\">(</span><span class=\"nb\">cons</span> <span class=\"p\">(</span><span class=\"nv\">concat</span> <span class=\"nv\">method-name</span> <span class=\"s\">\"i\"</span><span class=\"p\">)</span>          <span class=\"nv\">method-def-args</span><span class=\"p\">)))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki--get-enriched-with-new-tramp-methods</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"nv\">-map-when</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">member</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"nv\">tramp-plinki-methods</span><span class=\"p\">))</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nv\">thread-first</span> <span class=\"nv\">e</span>            <span class=\"c1\">;; (tramp-plinki--register-tramp-completion-fun)</span>            <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--suffix-method-name</span><span class=\"p\">)</span>            <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--add-certificate-login-arg-to-method</span><span class=\"p\">)</span>            <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--add-certificate-copy-arg-to-method</span><span class=\"p\">)))</span>   <span class=\"nv\">tramp-methods</span><span class=\"p\">))</span><span class=\"p\">(</span><span class=\"nb\">defun</span> <span class=\"nv\">tramp-plinki-register-new</span> <span class=\"p\">()</span>  <span class=\"p\">(</span><span class=\"nb\">when</span> <span class=\"p\">(</span><span class=\"nb\">not</span> <span class=\"nv\">tramp-plinki-ppk</span><span class=\"p\">)</span>    <span class=\"p\">(</span><span class=\"nb\">error</span> <span class=\"s\">\"empty value for tramp-plinki-ppk\"</span><span class=\"p\">))</span>  <span class=\"p\">(</span><span class=\"k\">setq</span> <span class=\"nv\">tramp-methods</span> <span class=\"p\">(</span><span class=\"nv\">tramp-plinki--get-enriched-with-new-tramp-methods</span><span class=\"p\">))</span>  <span class=\"p\">(</span><span class=\"nv\">-map-when</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">member</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">e</span><span class=\"p\">)</span> <span class=\"nv\">tramp-plinki-methods</span><span class=\"p\">))</span>   <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span>     <span class=\"p\">(</span><span class=\"k\">let</span> <span class=\"p\">((</span><span class=\"nv\">method-name</span> <span class=\"p\">(</span><span class=\"nb\">car</span> <span class=\"nv\">tramp-method-def</span><span class=\"p\">))</span>           <span class=\"p\">(</span><span class=\"nv\">tramp-set-completion-function</span> <span class=\"p\">(</span><span class=\"nv\">concat</span> <span class=\"nv\">method-name</span> <span class=\"s\">\"i\"</span><span class=\"p\">)</span> <span class=\"nv\">tramp-completion-function-alist-ssh</span><span class=\"p\">)))</span>     <span class=\"no\">nil</span><span class=\"p\">)</span>   <span class=\"nv\">tramp-methods</span><span class=\"p\">))</span><span class=\"c1\">;; then run (tramp-plinki-register-new)</span></code></pre></div></div><p>The beauty of this is that if your key is not known to the remote host, it would still prompt you for a password without failing.</p>",
            "url": "http://0.0.0.0:4000/2019/12/05/tramp-autologin-insanity",
            
            
            
            
            
            "date_published": "2019-12-05T00:00:00+00:00",
            "date_modified": "2019-12-05T00:00:00+00:00",
            
                "author":  {
                "name": "Colorie",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}